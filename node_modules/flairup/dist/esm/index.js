// src/utils/is.ts
var is = {
  pseudoSelector: (selector, _) => selector.startsWith(":"),
  mediaQuery: (property, _) => property.startsWith("@media"),
  directClass: (property, _) => property === ".",
  cssVariables: (property, _) => property === "--",
  validProperty: (property, value) => (typeof value === "string" || typeof value === "number") && !is.cssVariables(property, value) && !is.pseudoSelector(property, value) && !is.mediaQuery(property, value),
  topLevelClass: (property, _) => property.startsWith(".") && property.length > 1,
  string: (value) => typeof value === "string"
};

// src/utils/stableHash.ts
function stableHash(prefix, seed) {
  let hash = 0;
  if (seed.length === 0)
    return hash.toString();
  for (let i = 0; i < seed.length; i++) {
    const char = seed.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return `${prefix ?? "cl"}_${hash.toString(36)}`;
}

// src/utils/stringManipulators.ts
function genCssRule(classes, property, value) {
  return genCssRules(classes, genLine(property, value));
}
function genLine(property, value) {
  return `${camelCaseToDash(property)}: ${handlePropertyValue(
    property,
    value
  )};`;
}
function handlePropertyValue(property, value) {
  if (property === "content") {
    return `"${value}"`;
  }
  return value;
}
function genCssRules(classes, content) {
  return `${makeClassName(classes)} ${wrapWithCurlys(content)}`;
}
function wrapWithCurlys(content, breakLine = false) {
  return [breakLine ? "{\n" : "{", content, breakLine ? "\n}" : "}"].join("");
}
function camelCaseToDash(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function joinedProperty(property, value) {
  return `${property}:${value}`;
}
function chunkSelector(className, property) {
  const base = makeClassName(className);
  if (is.pseudoSelector(property)) {
    return `${base}${property}`;
  }
  if (is.mediaQuery(property)) {
    return `${property}`;
  }
  return base;
}
function makeClassName(classes) {
  return classes.filter(Boolean).map((c) => `.${c}`).join(" ");
}
function appendString(base, line) {
  return base ? `${base}
${line}` : line;
}

// src/Sheet.ts
var Sheet = class {
  constructor(name) {
    this.name = name;
    // Hash->css
    this.storedStyles = {};
    // styles->hash
    this.storedClasses = {};
    this.style = "";
    this.count = 0;
    this.id = `flairup-${name}`;
    this.styleTag = this.createStyleTag();
  }
  getStyle() {
    return this.style;
  }
  append(css) {
    this.style = appendString(this.style, css);
  }
  apply() {
    this.count++;
    if (!this.styleTag) {
      return;
    }
    this.styleTag.innerHTML = this.style;
  }
  isApplied() {
    return !!this.styleTag;
  }
  createStyleTag() {
    if (typeof document === "undefined" || this.isApplied()) {
      return;
    }
    const styleTag = document.createElement("style");
    styleTag.type = "text/css";
    styleTag.id = this.id;
    document.head.appendChild(styleTag);
    return styleTag;
  }
  addRule(property, value, parentClassName = "") {
    const key = joinedProperty(property, value) + parentClassName;
    const storedClass = this.storedClasses[key];
    if (is.string(storedClass)) {
      return storedClass;
    }
    const hash = stableHash(this.name, key);
    this.storedClasses[key] = hash;
    this.storedStyles[hash] = [property, value];
    this.append(genCssRule([parentClassName, hash], property, value));
    return hash;
  }
};

// src/utils/forIn.ts
function forIn(obj, fn) {
  for (const key in obj) {
    fn(key.trim(), obj[key]);
  }
}

// src/cx.ts
function cx(...args) {
  const classes = args.reduce((classes2, arg) => {
    if (arg instanceof Set) {
      classes2.push(...arg);
    } else if (typeof arg === "string") {
      classes2.push(arg);
    } else if (Array.isArray(arg)) {
      classes2.push(cx(...arg));
    } else if (typeof arg === "object") {
      Object.entries(arg).forEach(([key, value]) => {
        if (value) {
          classes2.push(key);
        }
      });
    }
    return classes2;
  }, []);
  return classes.filter(Boolean).join(" ").trim();
}

// src/index.ts
function createSheet(name) {
  const sheet = new Sheet(name);
  return {
    create,
    getStyle: sheet.getStyle.bind(sheet),
    isApplied: sheet.isApplied.bind(sheet)
  };
  function create(styles) {
    const scopedStyles = {};
    forIn(styles, (scopeName, styles2) => {
      const scopeClassName = stableHash(sheet.name, scopeName);
      if (is.topLevelClass(scopeName, styles2)) {
        forIn(styles2, (property, value) => {
          iterateStyles(
            sheet,
            value,
            scopeClassName,
            scopeName.slice(1)
          ).forEach((className) => {
            addScopedStyle(property, className);
          });
        });
        return;
      }
      iterateStyles(sheet, styles2, scopeClassName).forEach(
        (className) => {
          addScopedStyle(scopeName, className);
        }
      );
    });
    sheet.apply();
    return scopedStyles;
    function addScopedStyle(name2, className) {
      scopedStyles[name2] = scopedStyles[name2] ?? /* @__PURE__ */ new Set();
      scopedStyles[name2].add(className);
    }
  }
}
function iterateStyles(sheet, styles, scopeClassName, parentClassName) {
  const output = /* @__PURE__ */ new Set();
  forIn(styles, (property, value) => {
    if (is.directClass(property, value)) {
      return handleAddedClassnames(value).forEach(
        (classes) => output.add(classes)
      );
    }
    if (is.mediaQuery(property, value)) {
      return handleMediaQuery(sheet, value, property, scopeClassName).forEach(
        (className) => output.add(className)
      );
    }
    if (is.pseudoSelector(property, value) || is.cssVariables(property, value)) {
      return handleChunks(sheet, value, property, scopeClassName).forEach(
        (classes) => output.add(classes)
      );
    }
    if (is.validProperty(property, value)) {
      const ruleClassName = sheet.addRule(property, value, parentClassName);
      return output.add(ruleClassName);
    }
  });
  return output;
}
function handleAddedClassnames(classes) {
  return [].concat(classes);
}
function handleChunks(sheet, styles, property, scopeClassName) {
  const classes = /* @__PURE__ */ new Set();
  const chunkRows = [];
  forIn(styles, (property2, value) => {
    if (is.validProperty(property2, value)) {
      chunkRows.push(genLine(property2, value));
      return;
    }
    iterateStyles(sheet, value ?? {}, scopeClassName).forEach(
      (className) => classes.add(className)
    );
  });
  if (chunkRows.length) {
    const output = chunkRows.join(" ");
    sheet.append(
      `${chunkSelector([scopeClassName], property)} ${wrapWithCurlys(
        output,
        true
      )}`
    );
  }
  classes.add(scopeClassName);
  return classes;
}
function handleMediaQuery(sheet, styles, property, scopeClassName) {
  sheet.append(chunkSelector([scopeClassName], property) + " {");
  const output = iterateStyles(sheet, styles, scopeClassName);
  sheet.append("}");
  return output;
}
export {
  createSheet,
  cx
};
//# sourceMappingURL=index.js.map